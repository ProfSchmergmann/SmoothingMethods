---
title: "HW6 - Lucas Fellmeth, Sven Bergmann"
date: "2023-11-29"
output: pdf_document
latex_engine: xelatex
---

```{r setup, echo = F}
library(knitr)
opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
```
# 1
The goal of this problem is to estimate the regression function of acceleration vs time for the `mcycle` data in the package `MASS`, using cubic smoothing splines.

```{r}
library(MASS)
library(splines)
library(splines2)
```

## A
For a reasonable range of smoothing parameters $\lambda$, compute and plot the generalized cross validation measure $GCV(\lambda)$ and find the optimal smoothing parameter.

```{r, out.width = "50%", out.height = "50%"}
with(mcycle, {
  lambda <- seq(10^(-6), 10^(-3), by = 10^(-6))

  smoothing <- function(l, x, y) {
    return(smooth.spline(x, y, lambda = l)$cv.crit)
  }

  gcv <- sapply(lambda, smoothing, x = accel, y = times)
  tmp <- data.frame(lambda = lambda, gcv = gcv)
  lambda_opt <<- tmp[which.min(tmp$gcv),]$lambda
  plot(tmp, type = 'l')
  plot.new()
  plot(times, accel, main = paste('min_lambda =', lambda_opt))
  lines(smooth.spline(x = times, y = accel, lambda = lambda_opt), col = 'red', type = 'l')
})
```

## B
Using the Demmler-Reinsch basis representation, how many basis functions contribute significantly to the fit, as determined, for instance, by accumulating $90\%$ of the total degrees of freedom?

https://statisticaloddsandends.wordpress.com/2019/10/04/the-demmler-reinsch-basis-for-smoothing-splines/
```{r}
data(mcycle)
knots <- mcycle$times[3:131]
length(knots)
upper <- ceiling(max(mcycle$times))
Phi <- bSpline(mcycle$times, knots = knots, degree = 3, intercept = T, Boundary.knots = c(0, upper))
out <- svd(Phi)
D <- diag(out$d)
V <- out$v
R <- D%*%t(V)
delta <- t[2] - t[1]
t <- seq(0, upper, length.out = 200)
Phi2 <- bSpline(t, knots = knots, degree = 3, intercept = T, Boundary.knots = c(0, upper), derivs = 2)
Omega <- delta * t(Phi2) %*% Phi2
Phi0 <- bSpline(t, knots = knots, degree = 3, intercept = T, Boundary.knots = c(0, upper))
#H <- Phi %*% ginv(t(Phi) %*% Phi + lambda_opt * Omega)
#sum(diag(H))


```
```{r}
Sigma <- ginv(t(R)) %*% Omega %*% solve(V)
S <- eigen(Sigma)$values
U <- eigen(Sigma)$vectors
Psi <- Phi %*% ginv(R) %*% U
Psi0 <- Phi0 %*% ginv(R) %*% U
plot(t,Psi0[,133],type="l")



```

```{r}
plot(1:133,1/(1+0*S))
plot(1:133,1/(1+lambda_opt*S))
sum(1/(1+lambda_opt*S))
```
```{r}
with(mcycle, {
  knots <- times
  t <- seq(0, ceiling(max(knots)), length.out = 500)
  Phi <- bSpline(times, knots = knots, degree = 3, intercept = T, Boundary.knots = c(0, ceiling(max(knots))))
  delta <- t[2] - t[1]
  Phi2 <- bSpline(t, knots = knots, degree = 3, intercept = T, Boundary.knots = c(0, ceiling(max(knots))), derivs = 2)
  Omega <- delta * t(Phi2) %*% Phi2
  temp <- t(Phi) %*% Phi + lambda_opt * Omega
  H <<- Phi %*% ginv(t(Phi) %*% Phi + lambda_opt * Omega)
  trace <- sum(diag(H))
  V <- eigen(t(Phi) %*% Phi)$vectors
  D2 <- eigen(t(Phi) %*% Phi)$values

})

```
